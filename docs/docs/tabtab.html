<!doctype html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!-- Consider adding a manifest.appcache: h5bp.com/d/Offline -->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>tabtab :: a package configuration/options parsing/documentation/completion tool.</title>
  <meta name="description" content="a package configuration/options parsing/documentation/completion tool. ">
  <meta name="author" content="mklabs">
  <!-- Mobile viewport optimized: j.mp/bplateviewport -->
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    /* HTML5 ✰ Boilerplate
     * ==|== normalize ==========================================================
     */
    article, aside, details, figcaption, figure, footer, header, hgroup, nav, section { display: block; }
    audio, canvas, video { display: inline-block; *display: inline; *zoom: 1; }
    audio:not([controls]) { display: none; }
    [hidden] { display: none; }
    html { font-size: 100%; overflow-y: scroll; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }
    body { margin: 0; font-size: 13px; line-height: 1.231; }
    body, button, input, select, textarea { font-family: sans-serif; color: #222; }
    ::-moz-selection { background: #fe57a1; color: #fff; text-shadow: none; }
    ::selection { background: #fe57a1; color: #fff; text-shadow: none; }
    a { color: #00e; }
    a:visited { color: #551a8b; }
    a:hover { color: #06e; }
    a:focus { outline: thin dotted; }
    a:hover, a:active { outline: 0; }
    abbr[title] { border-bottom: 1px dotted; }
    b, strong { font-weight: bold; }
    blockquote { margin: 1em 40px; }
    dfn { font-style: italic; }
    hr { display: block; height: 1px; border: 0; border-top: 1px solid #ccc; margin: 1em 0; padding: 0; }
    ins { background: #ff9; color: #000; text-decoration: none; }
    mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; }
    pre, code, kbd, samp { font-family: monospace, monospace; _font-family: 'courier new', monospace; font-size: 1em; }
    pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; }
    q { quotes: none; }
    q:before, q:after { content: ""; content: none; }
    small { font-size: 85%; }
    sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
    sup { top: -0.5em; }
    sub { bottom: -0.25em; }
    ul, ol { margin: 1em 0; padding: 0 0 0 40px; }
    dd { margin: 0 0 0 40px; }
    nav ul, nav ol { list-style: none; list-style-image: none; margin: 0; padding: 0; }
    img { border: 0; -ms-interpolation-mode: bicubic; vertical-align: middle; }
    svg:not(:root) { overflow: hidden; }
    figure { margin: 0; }
    form { margin: 0; }
    fieldset { border: 0; margin: 0; padding: 0; }
    label { cursor: pointer; }
    legend { border: 0; *margin-left: -7px; padding: 0; }
    button, input, select, textarea { font-size: 100%; margin: 0; vertical-align: baseline; *vertical-align: middle; }
    button, input { line-height: normal; *overflow: visible; }
    table button, table input { *overflow: auto; }
    button, input[type="button"], input[type="reset"], input[type="submit"] { cursor: pointer; -webkit-appearance: button; }
    input[type="checkbox"], input[type="radio"] { box-sizing: border-box; }
    input[type="search"] { -webkit-appearance: textfield; -moz-box-sizing: content-box; -webkit-box-sizing: content-box; box-sizing: content-box; }
    input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }
    button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }
    textarea { overflow: auto; vertical-align: top; resize: vertical; }
    input:valid, textarea:valid {  }
    input:invalid, textarea:invalid { background-color: #f0dddd; }
    table { border-collapse: collapse; border-spacing: 0; }
    td { vertical-align: top; }
    /* ==|== primary styles =====================================================
       Author: 
       ========================================================================== */
    body {
      padding: 50px;
      color: #8b8b8b;
    }
    h1, h2, h3 {
      font-size: 33px;
      font-weight: normal;
      color: #333;
      -webkit-font-smoothing: antialiased;
    }
    h2 {
      padding: 5px 0;
      font-size: 24px;
      border-bottom: 3px solid #eee;
    }
    h3 {
      padding: 5px 0;
      font-size: 18px;
      border-bottom: 3px solid #eee;
    }
    a { color: #00e; text-decoration: none; }
    a:visited { color: #06e; }
    a:hover { color: #06e; text-decoration: underline; }
    a:focus { outline: thin dotted; }
    a:hover, a:active { outline: 0; }
    .docs { text-align: right }
    /* ==|== non-semantic helper classes ======================================== */
    .ir { display: block; border: 0; text-indent: -999em; overflow: hidden; background-color: transparent; background-repeat: no-repeat; text-align: left; direction: ltr; }
    .ir br { display: none; }
    .hidden { display: none !important; visibility: hidden; }
    .visuallyhidden { border: 0; clip: rect(0 0 0 0); height: 1px; margin: -1px; overflow: hidden; padding: 0; position: absolute; width: 1px; }
    .visuallyhidden.focusable:active, .visuallyhidden.focusable:focus { clip: auto; height: auto; margin: 0; overflow: visible; position: static; width: auto; }
    .invisible { visibility: hidden; }
    .clearfix:before, .clearfix:after { content: ""; display: table; }
    .clearfix:after { clear: both; }
    .clearfix { zoom: 1; }
    /* ==|== media queries ====================================================== */
    @media only screen and (min-width: 480px) {
    }
    @media only screen and (min-width: 768px) {
    }
    /* ==|== print styles ======================================================= */
    @media print {
      * { background: transparent !important; color: black !important; text-shadow: none !important; filter:none !important; -ms-filter: none !important; } 
      a, a:visited { text-decoration: underline; }
      a[href]:after { content: " (" attr(href) ")"; }
      abbr[title]:after { content: " (" attr(title) ")"; }
      .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; } 
      pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
      thead { display: table-header-group; }
      tr, img { page-break-inside: avoid; }
      img { max-width: 100% !important; }
      @page { margin: 0.5cm; }
      p, h2, h3 { orphans: 3; widows: 3; }
      h2, h3 { page-break-after: avoid; }
    }
  </style>
</head>
<body>
  <header>
    <h1>tabtab<h1>
    <h2>a package configuration/options parsing/documentation/completion tool.</h2>
  </header>
  <div role="main">
          <p class="docs"><a href="./docs/completion.html">Moar docs</a></p>
    <p>a npm package to do some custom command line<code>&lt;tab&gt;&lt;tab&gt;</code> completion for any system command, using the node api and JS to provide your own completion, for both bash/zsh shell.</p>

<p>Made possible using the same technique as npm (whose completion is quite awesome) relying on a bash/zsh completion script bridge to a node script.</p>

<p>If you&#39;d like to implement some completion for your own nodejs cli app,
or maybe any other command on your system (think not necessaraly an npm
package) using regular JavaScript instead of bash scripting, this repository can help you.</p>

<p>Comes with built-in completion, mainly as examples, for rake
(tasks/options), cake (tasks/options), vagrant (tasks) and play (tasks).</p>

<p>And a more generally purpose example doing completion with some of the
most robust and well-known options parsing and cli modules:</p>

<ul><li><a href="[https://github.com/isaacs/nopt](https://github.com/isaacs/nopt)">nopt</a></li><li><a href="[https://github.com/substack/node-optimist](https://github.com/substack/node-optimist)">optimist</a></li><li><a href="[https://github.com/visionmedia/commander.js](https://github.com/visionmedia/commander.js)">commander.js</a></li></ul>

<p>The main modules include some basic helpers for parsing help output (where
in most of cases it is enough to get sensitive informations on the process
being completed), and logging completion filtered on the text being
completed.</p>

<h3>install</h3>

<p>Latest released version (when it&#39;ll get released)</p>

<pre><code>npm install tabtab -g</code></pre>

<p>Latest dev code:</p>

<pre><code>npm install [https://github.com/mklabs/node-tabtab/tarball/master](https://github.com/mklabs/node-tabtab/tarball/master) -g</code></pre>

<p>Or
    git clone <a href="https://github.com/mklabs/node-tabtab.git">https://github.com/mklabs/node-tabtab.git</a>
    cd tabtab
    npm link</p>

<h3>setting up a new completion</h3>

<p>To install follow the installation instructions in the <code>completer completion</code>
output or <code>completer</code>. A completer is one of the script in <code>bin/</code>, that
gets linked to your $PATH by npm during global install or link.</p>

<p>You simply need to redirect the output of the command in your
~/.basrc or ~/.zshrc file. Example for completing tasks and options for
cake</p>

<pre><code>cake-completer completion &gt;&gt; ~/.bashrc
# or if zsh
cake-completer completion &gt;&gt; ~/.zshrc</code></pre>

<p>Then, make sure to open a new shell session to make sure the
.bashrc/.zshrc file is loaded, or do it manually by running <code>source ~/.bashrc</code> (or
.zshrc).</p>

<p>npm completion is pretty amazing and would allow you to discover some
options and commands you might not know about.</p>

<h4>install/uninstall</h4>

<p>You can instead make use of install/uninstall completion command, here
is the output of</p>

<pre><code>$ rake-complete
rake-complete called outside of a completion context.
» You may want to setup the completion in your ~/.bashrc or ~/.zshrc file, if not already.

   rake-complete completion &gt;&gt; ~/.bashrc
Or
   rake-complete completion &gt;&gt; ~/.zshrc

Or you may use the install command
   rake-complete completion install

Simply run this command to uninstall
   rake-complete completion uninstall</code></pre>

<p>The install command does pretty much the same as <code>rake-complete
completion &gt;&gt; ~/.bashrc</code> and edit ~/.bashrc or ~/.zshrc depending on the
value of <code>process.env.SHELL</code>. It also ensures that the script is not
already installed.</p>

<p>The uninstall command reverts the install.</p>

<h3>help</h3>

<p>Type <code>tabtab help</code> to get the content of this readme as manpage.</p>

<h3>using it in node cli app</h3>

<p>You can add completion pretty easily in your node cli script:</p>

<pre><code>#!/usr/bin/env node
var completion = require(&#39;../lib/completion&#39;), // todo: replace this the package name
  exec = require(&#39;child_process&#39;).exec,
  path = require(&#39;path&#39;),
  completer = path.basename(__filename);

completion.complete(&#39;pkgname&#39;, function(err, data) {
  // simply return here if there&#39;s an error or data not provided.
  // stderr not showing on completions
  if(err || !data) return;

  if(/^--\w?/.test(data.last)) return completion.log([&#39;help&#39;, &#39;version&#39;], data, &#39;--&#39;);
  if(/^-\w?/.test(data.last)) return completion.log([&#39;n&#39;, &#39;o&#39;, &#39;d&#39;, &#39;e&#39;], data, &#39;-&#39;);

  completion.log([&#39;list&#39;, &#39;of&#39;, &#39;commands&#39;], data);
});

// prevent main script from running when called on completion
if(completion.isComplete()) return;

// The rest of your script
...</code></pre>

<p>Simply replace <code>pkgname</code> by the name of your package (not yet
implemented: or pass in the module reference, package name will be read
from the package.json).</p>

<p>The complete callback get&#39;s called with data only in the context of a
completion command, and the main script should be run only when it&#39;s not
a completion command.</p>

<p>The <code>data</code> object holds interesting value to drive the output of the
completion:</p>

<ul><li>line: full command being completed</li><li>words: number of word</li><li>point: cursor position</li><li>partial: tabing in the middle of a word: foo bar baz bar foobar&lt;tab&gt;&lt;tab&gt;rrrrrr</li><li>last: last word of the line</li><li>lastPartial: last partial of the line</li><li>prev: the previous word</li></ul>

<p>Installing the completion for your cli app is done very much like npm:</p>

<pre><code>pkgname completion &gt;&gt; ~/.bashrc (or ~/.zshrc)</code></pre>

<p>Or</p>

<pre><code>pkgname completion install</code></pre>

<p>To desinstall:</p>

<pre><code>pkgname completion uninstall</code></pre>

<h2>API</h2>

<h3>complete</h3>

<p>Main completion method, has support for installation and actual completion.</p>

<pre><code>   completion.complete(completed, completer, callback);</code></pre>

<ul><li>completed: name of the command to complete</li><li>completer: <em>Optional</em> name of the command to call on completion (when
not set, completed and completer are the same)</li><li>callback that will get called when the match when the completion happens.</li></ul>

<p>completed and completer are there only to set up and build the correct
bash/zsh script, based on the <code>lib/completion/completion.sh</code> template.</p>

<h3>log</h3>

<p>Helper to return completion output and log to standard output.</p>

<pre><code>   completion.log([&#39;list&#39;, &#39;of&#39;, &#39;values&#39;], data, prefix);</code></pre>

<ul><li>values: Array of values to complete</li><li>data: the data returned by the complete callback, used mainly to
filter results accordingly upon the text that is supplied by the user.</li><li>prefix: <em>Optional</em> a prefix to add to the completion results, useful
for options to add dashes (eg. <code>-</code> or <code>--</code>)</li></ul>

<h3>parseOut</h3>

<p>Helper to return the list of short and long options, parsed from the
usual <code>--help</code> output of a command (cake/rake -H, vagrant, commander -h,
optimist.help(), ...)</p>

<pre><code>   var parsed = completion.parseOut(optimist.help());
   console.log(parsed.shorts);
   console.log(parsed.longs);</code></pre>

<p>Using a spawned process:</p>

<pre><code>   return exec(&#39;rake -H&#39;, function(err, stdout, stderr) {
     if(err) return;
     var parsed = parseOut(stdout);
     if(/^--\w?/.test(o.last)) return log(parsed.longs, o, &#39;--&#39;);
     if(/^-\w?/.test(o.last)) return log(parsed.shorts, o, &#39;-&#39;);
   });</code></pre>

<h3>parseTasks</h3>

<p>same purpose as parseOut, but for parsing tasks from an help command
(cake/rake -T, vagrant, etc.)</p>

<pre><code>   exec(&#39;cake&#39;, function(err, stdout, stderr) {
     if(err) return;
     var parsed = tasks = parseTasks(stdout, &#39;cake&#39;);
     log(tasks, o);
   });</code></pre>

<ul><li>stdout: string of help output</li><li>prefix: prefix used internally to build the RegExp that is used to
parse tasks from stdout.</li></ul>

<h2>Credits</h2>

<p>npm does pretty amazing stuff with its completion feature. Bash and
zsh shells allow command completion, typically bound to the TAB key,
which allow you to complete the names of commands stored upon your PATH.
Usually these functions means bash scripting, and in the case of npm, it
is partially true.</p>

<p>There is a special <code>npm completion</code> command you may want to look around, it not already.</p>

<pre><code>npm completion</code></pre>

<p>Running this should dump <a href="[https://raw.github.com/isaacs/npm/[caafb73](http://github.com/mklabs/node-tabtab/commit/caafb7323708e113d100e3e8145b949ed7a16c22)/lib/utils/completion.sh](https://raw.github.com/isaacs/npm/[caafb73](http://github.com/mklabs/node-tabtab/commit/caafb7323708e113d100e3e8145b949ed7a16c22)/lib/utils/completion.sh)">this
script</a>
to the console. This script works with both bash/zsh and map the correct
completion functions to the npm executable. These functions takes care
of parsing the <code>COMP_*</code> variables available when hitting TAB to complete
a command, set them up as environment variables and run the <code>npm
completion</code> command followed by <code>-- words</code> where words match value of
the command being completed.</p>

<p>This means that using this technique npm manage to perform bash/zsh
completion using node and JavaScript. Actually, the completeness of npm
completion is quite amazing.</p>

<p>This whole package/module is based entirely on npm&#39;s code and @isaacs
work.</p>
  </div>
</body>
</html>